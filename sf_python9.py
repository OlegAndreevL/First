# Дан список из кортежей temps. На первом месте в кортеже указан год в виде строки, 
# а на втором — средняя температура января в Петербурге в указанном году.
# Напишите функцию check(temps), которая будет выводить словарь, в котором ключи — годы, 
# а значения — показатели температуры. Ключи необходимо отсортировать в порядке убывания соответствующих им температур.
# temps = [('2000', -4.4), ('2001', -2.5), ('2002', -4.4), ('2003', -9.5)]
# from collections import OrderedDict
# def check(temps):
#     ord_temp = OrderedDict(sorted(temps, key=lambda x: -x[1]))
#     print(ord_temp)
# check(temps)

# Напишите функцию brackets(line), которая определяет, является ли последовательность из круглых скобок line правильной.
# Примечание 1. Какая последовательность скобок правильная?
# Правильной скобочной последовательностью назовём такую последовательность скобок, 
# в которой для каждой открывающей скобки есть последующая соответствующая ей закрывающая скобка. 
# Соответственно, остальные скобочные последовательности назовём неправильными. 
# Пустую строку будем считать правильной последовательностью.
# Примечание 2.Для решения этой задачи потребуется использовать стек.
# Посимвольно переберите строку. Если встретилась открывающаяся скобка, положите её в стек. 
# Если встретилась закрывающаяся скобка, извлеките скобку из стека.
# Если стек пустой, то есть извлечь скобку нельзя, последовательность неправильная.
# Если строка закончилась и стек стал пустым, последовательность правильная.
# Если в стеке остались скобки, последовательность неправильная.
# from collections import deque
# def brackets(line):
#     opens = deque()
#     for i in line:
#         if i == '(':
#             opens.append(i)
#         elif i == ')':
#             if opens:
#                 opens.pop()   
#             else:
#                 return False
#     if opens:
#         return False
#     return True
# brackets(")(")

# Дан список кортежей ratings, где каждый кортеж содержит название и рейтинг кафе.
# Необходимо отсортировать список по убыванию рейтинга. Если рейтинги совпадают, 
# то кафе должны быть дополнительно отсортированы в алфавитном порядке.
# После сортировки создайте упорядоченный словарь cafes, используя модуль collections. 
# Ключами должны быть названия кафе, а значениями — их рейтинги.
# Используйте следующий список с рейтингами кафе:
# ratings = [
# ('Old York', 3.3), ('New Age', 4.6), ('Old Gold', 3.3), ('General Foods', 4.8),
# ('Belissimo', 4.5), ('CakeAndCoffee', 4.2), ('CakeOClock', 4.2), ('CakeTime', 4.1),
# ('WokToWork', 4.9), ('WokAndRice', 4.9), ('Old Wine Cellar', 3.3), ('Nice Cakes', 3.9)
# ]
# from collections import OrderedDict
# sor_rat = sorted(ratings, key=lambda x: (-x[1], x[0]))
# cafes = OrderedDict(sor_rat)
# print(cafes)

# Напишите функцию task_manager(tasks), которая принимает список задач tasks для нескольких серверов. 
# Каждый элемент списка состоит из кортежа (<номер задачи>, <название сервера>, <высокий приоритет задачи>).
# Функция должна создавать словарь и заполнять его задачами по следующему принципу: название сервера — ключ, 
# по которому хранится очередь задач для конкретного сервера.
# Если поступает задача без высокого приоритета (последний элемент кортежа — False), добавить номер задачи в конец очереди. 
# Если приоритет высокий, добавить номер в начало.
# Для словаря используйте defaultdict, для очереди — deque.
# tasks = [(36871, 'office', False),
# (40690, 'office', False),
# (35364, 'voltage', False),
# (41667, 'voltage', True),
# (33850, 'office', False)]
# from collections import defaultdict, deque
# def task_manager(tasks):
#     ord_tasks = defaultdict(deque)
#     for number, server, imp in tasks:
#         if imp == False:
#             ord_tasks[server].append(number)
#         else:
#             ord_tasks[server].appendleft(number)
#     print(ord_tasks)                                  Здесь должен быть return, не работает!!!!
# task_manager(tasks)

# Вам дан массив mystery
# Выполните все пукты задания по порядку.
# Пожалуйста, не меняйте названия переменных, в которых должны появиться ответы.
# 1.В переменную elem_5_3 сохраните элемент из 5 строки и 3 столбца
# 2.В переменную last сохраните элемент из последней строки последнего столбца
# 3.В переменную line_4 сохраните строку 4
# 4.В переменную col_2 сохраните предпоследний столбец
# 5.Из строк 2-4 (включительно) получите столбцы 3-5 (включительно). Результат сохраните в переменную part
# 6.Сохраните в переменную rev последний столбец в обратном порядке
# 7.Сохраните в переменную trans транспонированный массив
# import numpy as np
# mystery = np.array([[-13586,  15203,  28445, -27117,  -1781, -17182, -18049],
#        [ 25936, -30968,  -1297,  -4593,   6451,  15790,   7181],
#        [ 13348,  28049,  28655,  -6012,  21762,  25397,   8225],
#        [ 13240,   7994,  32592,  20149,  13754,  11795,   -564],
#        [-21725,  -8681,  30305,  22260, -17918,  12578,  29943],
#        [-16841, -25392, -17278,  11740,   5916,    -47, -32037]],
#       dtype=np.int16)
# elem_5_3 = mystery[4,2]
# last = mystery[-1, -1]
# line_4 = mystery[3]
# col_2 = mystery[:, -2]
# part = mystery[1:4, 2:5]
# revh = mystery[:, -1]
# rev = revh[::-1]
# trans = mystery.transpose()

# Вам дан массив mystery:
# Получите булевый массив nans_index с информацией о np.nan в массиве mystery: 
#     True - значение пропущено, False - значение не пропущено
# В переменную n_nan сохраните число пропущенных значений
# Скопируйте массив mystery в массив mystery_new. Заполните пропущенные значения в массиве mystery_new нулями
# Поменяйте тип данных в массиве mystery на int32 и сохраните в переменную mystery_int
# Отсортируйте значения в массиве mystery по возрастанию и сохраните результат в переменную array
# Сохраните в массив table двухмерный массив, полученный из массива array. 
#     В нём должно быть 5 строк и 3 столбца. Причём порядок заполнения должен быть по столбцам!
# Например,
#  1, 2, 3, 4 -> 1    3
#                2    4
# Сохраните в переменную col средний столбец из table
# Примечание. Не меняйте названия переменных.
# import numpy as np
# mystery = np.array([ 12279., -26024.,  28745.,  np.nan,  31244.,  -2365.,  -6974.,
#         -9212., np.nan, -17722.,  16132.,  25933.,  np.nan, -16431.,
#         29810.], dtype=np.float32)
# nans_index = np.isnan(mystery)
# n_nan = 0
# for i in nans_index:
#     if i == True:
#         n_nan += 1
# mystery_new = np.array(mystery)
# mystery_new[np.isnan(mystery_new)] = 0
# mystery_int = np.array(mystery, dtype=np.int32)
# array = np.sort(mystery)
# table = array.reshape((5, 3), order='F')
# col = table[:, 1]

# Задайте seed = 2021.
# Сохраните в переменные необходимые значения.
# Примечание 1. Не меняйте названия переменных и последовательность генерации случайных чисел в задании.
# Примечание 2. Не забудьте импортировать numpy и сразу задать seed = 2021
# Примечание 3. Необходимый тип данных в подзаданиях — numpy.array.
# В simple сохраните случайное число в диапазоне от 0 до 1
# Сгенерируйте 120 чисел в диапазоне от -150 до 2021, сохраните их в переменную randoms
# Получите массив из случайных целых чисел от 1 до 100 (включительно) из 3 строк и 2 столбцов. Сохраните результат в table
# В переменную even сохраните четные числа от 2 до 16 (включительно)
# Скопируйте even в переменную mix. Перемешайте числа в mix так, чтобы массив изменился
# Получите из even 3 числа без повторений. Сохраните их в переменную select
# Получите переменную triplet, которая должна содержать перемешанные значения из массива select (сам select измениться не должен)
# import numpy as np
# np.random.seed(2021)
# simple = np.random.rand()
# randoms = np.random.uniform(-150, 2021, size=120)
# table = np.random.randint(1, 101, size=(3, 2))
# even = np.arange(2, 17, 2)
# mix = np.random.permutation(even)
# select = np.random.choice(even, size=3, replace=False)
# triplet = np.random.permutation(select)

# Напишите функцию get_chess(a), которая принимает на вход длину стороны квадрата a 
# и возвращает двумерный массив формы (a, a), заполненный 0 и 1 в шахматном порядке. В левом верхнем углу всегда должен быть ноль.
# Примечание. воспользуйтесь функцией np.zeros, а затем с помощью срезов без циклов задайте необходимым элементам значение 1.
# В Python для получения каждого второго элемента используется срез [::2]. 
# Подумайте, как грамотно применить этот принцип к двумерному массиву.
# get_chess(1)
# array([[0.]])
# get_chess(4)
# array([[0., 1., 0., 1.],
#        [1., 0., 1., 0.],
#        [0., 1., 0., 1.],
#        [1., 0., 1., 0.]])
# import numpy as np
# def get_chess(a):
#     sq = np.zeros((a, a))
#     sq[::2, 1::2] = 1
#     sq[1::2, ::2] = 1
#     print(sq)                             Опять не работает return!!!!!
# get_chess(5)

# Вы разрабатываете приложение для прослушивания музыки. Конечно же, там будет доступна функция перемешивания плейлиста. 
# Пользователю может настолько понравиться перемешанная версия плейлиста, что он захочет сохранить его копию. 
# Однако вы не хотите хранить в памяти новую версию плейлиста, а просто хотите сохранять тот seed, с которым он был сгенерирован.
# Для этого напишите функцию shuffle_seed(array), которая принимает на вход массив из чисел, 
# генерирует случайное число для seed в диапазоне от 0 до 2**32 - 1 (включительно) и возвращает кортеж: 
# перемешанный с данным seed массив (исходный массив должен оставаться без изменений), а также seed, с которым этот массив был получен.
# array = [1, 2, 3, 4, 5]
# shuffle_seed(array)
# (array([1, 3, 2, 4, 5]), 2332342819)
# shuffle_seed(array)
# (array([4, 5, 2, 3, 1]), 4155165971)
# import numpy as np
# def shuffle_seed(array):
#     num = np.random.randint(2**32, dtype=np.uint64)
#     np.random.seed(num)
#     mix = np.random.permutation(array)
#     print((mix, num))
# shuffle_seed([1, 2, 3, 4, 5])

# Напишите функцию min_max_dist(*vectors), которая принимает на вход неограниченное число векторов через запятую. 
# Гарантируется, что все векторы, которые передаются, одинаковой длины.
# Функция возвращает минимальное и максимальное расстояние между векторами в виде кортежа.
# vec1 = np.array([1,2,3])
# vec2 = np.array([4,5,6])
# vec3 = np.array([7, 8, 9])
# min_max_dist(vec1, vec2, vec3)
# (5.196152422706632, 10.392304845413264)
# import numpy as np
# def min_max_dist(*vectors):
#     max_dist = np.linalg.norm(vectors[0]-vectors[1])
#     min_dist = max_dist
#     for i in vectors:
#         for j in vectors:
#             if i is j:
#                 continue
#             else:
#                 dist = np.linalg.norm(i-j)
#                 if dist > max_dist:
#                     max_dist = dist
#                 elif dist < min_dist:
#                     min_dist = dist
#     print((min_dist, max_dist))

# Напишите функцию any_normal, которая принимает на вход неограниченное число векторов через запятую. 
# Гарантируется, что все векторы, которые передаются, одинаковой длины.
# Функция возвращает True, если есть хотя бы одна пара перпендикулярных векторов. Иначе возвращает False.
# import numpy as np
# def any_normal(*vectors):
#     for i in vectors:
#         for j in vectors:
#             if i is j:
#                 continue 
#             else:
#                 scalar = np.dot(i, j)
#                 if scalar == 0:
#                     return True
#     return False  
# vec1 = np.array([2, 1])
# vec2 = np.array([-1, 2])
# vec3 = np.array([3,4])
# any_normal(vec1, vec2, vec3)

# Напишите функцию get_loto(num), генерирующую трёхмерный массив случайных целых чисел от 1 до 100 (включительно). 
# Это поля для игры в лото.
# Трёхмерный массив должен состоять из таблиц чисел формы 5х5, то есть итоговая форма — (num, 5, 5).
# Функция возвращает полученный массив.
# import numpy as np
# def get_loto(num):
#     card = np.random.randint(1, 101, size=(num, 5, 5), dtype=np.uint32)
#     print(card)
# get_loto(3)

# Напишите функцию get_unique_loto(num). Она так же, как и функция в задании выше, 
# генерирует num полей для игры в лото, однако теперь на каждом поле 5х5 числа не могут повторяться.
# Функция также должна возвращать массив формы num x 5 x 5.
# import numpy as np
# def get_unique_loto(num):
#     sample = np.arange(1, 101)
#     res = list()
#     for i in range(num):
#         res.append(np.random.choice(sample, replace=False, size=(5, 5)))
#     res = np.array(res)
#     return res

    

